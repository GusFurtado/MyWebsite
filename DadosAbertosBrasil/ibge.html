<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>DadosAbertosBrasil.ibge API documentation</title>
<meta name="description" content="Módulo para captura dos dados abertos das APIs do IBGE …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:100%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Módulo <code>DadosAbertosBrasil.<span style='color:#009B3A'>ibge</span></code></h1>
</header>
<section id="section-intro">
<p>Módulo para captura dos dados abertos das APIs do IBGE.</p>
<h2 id="servicos-disponiveis">Serviços Disponíveis</h2>
<ul>
<li>Nomes 2.0</li>
<li>Agregados 3.0 (SIDRA)</li>
<li>Malhas Geográficas 2.0</li>
<li>Projeções 1.0</li>
<li>Localidades 1.0</li>
</ul>
<h2 id="mini-tutorial-de-sidra">Mini-Tutorial de SIDRA</h2>
<ol>
<li>Importe o módulo <code>ibge</code>.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; from DadosAbertosBrasil import ibge
</code></pre>
<li>Utilize a função <code><a title="DadosAbertosBrasil.ibge.lista_tabelas" href="#DadosAbertosBrasil.ibge.lista_tabelas">lista_tabelas</a></code> com os filtros necessários para encontrar
a tabela desejada.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; ibge.lista_tabelas( ... )
</code></pre>
<li>Utilize as funções <code><a title="DadosAbertosBrasil.ibge.lista_pesquisas" href="#DadosAbertosBrasil.ibge.lista_pesquisas">lista_pesquisas</a></code> e <code><a title="DadosAbertosBrasil.ibge.referencias" href="#DadosAbertosBrasil.ibge.referencias">referencias</a></code> para facilitar a busca.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; pesquisas = ibge.lista_pesquisas( ... )
&gt;&gt;&gt; referencias = ibge.referencias( ... )
</code></pre>
<li>Após obter o código numérico da tabela, insira-o como argumento de um
objeto <code><a title="DadosAbertosBrasil.ibge.Metadados" href="#DadosAbertosBrasil.ibge.Metadados">Metadados</a></code>.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; dados = ibge.Metadados(tabela)
</code></pre>
<li>Pelos atributos do objeto <code><a title="DadosAbertosBrasil.ibge.Metadados" href="#DadosAbertosBrasil.ibge.Metadados">Metadados</a></code>, veja quais são os valores
disponíveis para consulta desta tabela.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(dados.periodos)
&gt;&gt;&gt; print(dados.variaveis)
&gt;&gt;&gt; print(dados.localidades)
&gt;&gt;&gt; print(dados.classificacoes)
</code></pre>
<li>Utilize os valores encontrados nos metadados da tabela para alimentar a
função <code><a title="DadosAbertosBrasil.ibge.sidra" href="#DadosAbertosBrasil.ibge.sidra">sidra</a></code>.</li>
<pre><code class="language-python-repl">&gt;&gt;&gt; ibge.sidra( ... )
</code></pre></ol>
<h2 id="documentacao-da-api-original">Documentação original</h2>
<pre>- Serviços: <a href="https://servicodados.ibge.gov.br/api/docs">https://servicodados.ibge.gov.br/api/docs</a>
- SIDRA: <a href="http://api.sidra.ibge.gov.br/">http://api.sidra.ibge.gov.br/</a></pre>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Módulo para captura dos dados abertos das APIs do IBGE.

Serviços Disponíveis
--------------------
- Nomes 2.0
- Agregados 3.0 (SIDRA)
- Malhas Geográficas 2.0
- Projeções 1.0
- Localidades 1.0

Mini-Tutorial de SIDRA
----------------------
1. Importe o módulo `ibge`.
&gt;&gt;&gt; from DadosAbertosBrasil import ibge

2. Utilize a função `lista_tabelas` com os filtros necessários para encontrar
a tabela desejada.
&gt;&gt;&gt; ibge.lista_tabelas( ... )

3. Utilize as funções `lista_pesquisas` e `referencias` para facilitar a busca.
&gt;&gt;&gt; pesquisas = ibge.lista_pesquisas( ... )
&gt;&gt;&gt; referencias = ibge.referencias( ... )

4. Após obter o código numérico da tabela, insira-o como argumento de um
objeto `Metadados`.
&gt;&gt;&gt; dados = ibge.Metadados(tabela)

5. Pelos atributos do objeto `Metadados`, veja quais são os valores
disponíveis para consulta desta tabela.
&gt;&gt;&gt; print(dados.periodos)
&gt;&gt;&gt; print(dados.variaveis)
&gt;&gt;&gt; print(dados.localidades)
&gt;&gt;&gt; print(dados.classificacoes)

6. Utilize os valores encontrados nos metadados da tabela para alimentar a
função `sidra`.
&gt;&gt;&gt; ibge.sidra( ... )

Documentação original
----------------------------
Serviços
    https://servicodados.ibge.gov.br/api/docs
SIDRA
    http://api.sidra.ibge.gov.br/
&#39;&#39;&#39;



from typing import Union

import pandas as _pd
import requests

from . import API
from . import _utils



_api = API(&#39;sidra&#39;)

_normalize = _pd.io.json.json_normalize \
    if _pd.__version__[0] == &#39;0&#39; else _pd.json_normalize



def nomes(
        nomes: Union[list, str],
        sexo: str = None,
        localidade: int = None
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém a frequência de nascimentos por década dos nomes consultados.
    Defina o campo &#39;nomes&#39; com um string ou uma lista de string.
    Use os argumentos opcionais para definir sexo e localidade dos nomes.

    Parâmetros
    ----------
    nomes: list ou str
        Nome ou lista de nomes a ser consultado.
    sexo: str (default=None)
        - &#39;M&#39; para consultar apenas o nome de pessoas do sexo masculino;
        - &#39;F&#39; para consultar apenas o nome de pessoas do sexo feminino;
        - None para consultar ambos.
    localidade: int (default=None)
        Caso deseje obter a frequência referente a uma dada localidade,
        informe o parâmetro localidade. Por padrão, assume o valor BR,
        mas pode ser o identificador de um município ou de uma UF.
        Utilize a função `ibge.localidade` para encontrar a localidade
        desejada.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo a frequência de nascimentos por década para
        o(s) nome(s) consultado(s).

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    if isinstance(nomes, list):
        nomes = &#39;|&#39;.join(nomes)

    params = {}
    if sexo is not None:
        params[&#39;sexo&#39;] = sexo
    if localidade is not None:
        params[&#39;localidade&#39;] = _utils.parse_localidade(localidade)

    url = f&#34;https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nomes}&#34;
    data = requests.get(url, params=params).json()
    json = _pd.DataFrame(data)

    dfs = [_pd.DataFrame(json.res[i]).set_index(&#39;periodo&#39;) for i in json.index]
    df = _pd.concat(dfs, axis=1)
    df.columns = json.nome

    return df



def nomes_uf(nome: str) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém a frequência de nascimentos por UF para o nome consultado.

    Parâmetros
    ----------
    nome: str
        Nome que se deseja pesquisar.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo a frequência de nascimentos do nome pesquisado,
        agrupado por Unidade da Federação.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    if isinstance(nome, str):

        json = _pd.read_json(
            f&#34;https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nome}?groupBy=UF&#34;
        )

        df = _pd.DataFrame(
            [json[json.localidade == i].res.values[0][0] for i in json.localidade]
        )

        df.index = json.localidade
        df.sort_index(inplace=True)
        
    else:
        raise TypeError(&#34;O argumento &#39;nome&#39; deve ser do tipo string.&#34;)
    
    return df



def nomes_ranking(
        decada: int = None,
        sexo: str = None,
        localidade: int = None
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém o ranking dos nomes segundo a frequência de nascimentos por década.

    Parâmetros
    ----------
    decada: int (default=None)
        Deve ser um número múltiplo de 10 no formato AAAA.
    sexo: str (default=None)
        - &#39;M&#39; para consultar apenas o nome de pessoas do sexo masculino;
        - &#39;F&#39; para consultar apenas o nome de pessoas do sexo feminino;
        - None para consultar ambos.
    localidade: int (default=None)
        Caso deseje obter o ranking de nomes referente a uma dada localidade,
        informe o parâmetro localidade. Por padrão, assume o valor BR,
        mas pode ser o identificador de um município ou de uma UF.
        Utilize a função `ibge.localidade` para encontrar a localidade
        desejada.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo os nomes mais populadores dentro do universo de
        parâmetros pesquisados.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    query = &#39;https://servicodados.ibge.gov.br/api/v2/censos/nomes/ranking&#39;
    params = []
    
    if decada is not None:
        decada_error = &#34;O argumento &#39;decada&#39; deve ser um número inteiro multiplo de 10.&#34;
        if isinstance(decada, int):
            if decada%10 == 0:
                params.append(f&#39;decada={decada}&#39;)
            else:
                raise ValueError(decada_error)
        else:
            raise TypeError(decada_error)
    
    if localidade is not None:
        params.append(f&#39;localidade={_utils.parse_localidade(localidade)}&#39;)
            
    if sexo is not None:
        if sexo in [&#39;M&#39;, &#39;m&#39;, &#39;F&#39;, &#39;f&#39;]:
            params.append(f&#39;sexo={sexo.upper()}&#39;)
        else:
            raise ValueError(&#34;O argumento &#39;sexo&#39; deve ser um tipo &#39;string&#39; igual a &#39;M&#39; para masculino ou &#39;F&#39; para feminino.&#34;)
    
    params = &#39;&amp;&#39;.join(params)
    if params != &#39;&#39;:
        query += f&#39;?{params}&#39;
    
    return _pd.DataFrame(
        _pd.read_json(query).res[0]
    ).set_index(&#39;ranking&#39;)



def lista_tabelas(
        pesquisa: str = None,
        contendo: str = None,
        excluindo: str = None,
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Lista de tabelas disponíveis no SIDRA.

    Parâmetros
    ----------
    pesquisa: str (default=None)
        Código de duas letras da pesquisa que será buscada.
        Utilize a função `ibge_lista_pesquisas` para encontrar o código.
    contendo: str (default=None)
        Buscar apenas tabelas que contenham essa sequência de caracteres.
    excluindo: str (default=None)
        Buscar tabelas que não contenham essa sequência de caracteres.
    index: bool (default=False)
        Se True, define a coluna &#39;tabela_id&#39; como index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Lista de tabelas disponíveis no SIDRA.
    &#39;&#39;&#39;

    data = _api.get(&#39;&#39;)
    df = _normalize(
        data,
        &#39;agregados&#39;,
        [&#39;id&#39;, &#39;nome&#39;],
        record_prefix = &#39;tabela_&#39;,
        meta_prefix = &#39;pesquisa_&#39;
    )
    df.tabela_id = _pd.to_numeric(df.tabela_id)

    if isinstance(pesquisa, str):
        df = df[df.pesquisa_id == pesquisa.upper()]
    elif pesquisa == None:
        pass
    else:
        raise TypeError(&#34;O argumento &#39;pesquisa&#39; deve ser tipo string com duas letras.&#34;)
        
    if isinstance(contendo, str):
        df = df[df.tabela_nome.str.contains(contendo)]
    elif contendo == None:
        pass
    else:
        raise TypeError(&#39;O texto procurado deve ser tipo string.&#39;)
        
    if isinstance(excluindo, str):
        df = df[~df.tabela_nome.str.contains(excluindo)]
    elif excluindo == None:
        pass
    else:
        raise TypeError(&#39;O texto procurado deve ser tipo string.&#39;)

    if index:
        df.set_index(&#39;tabela_id&#39;, inplace=True)

    return df



def lista_pesquisas(
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Lista de pesquisas disponíveis no SIDRA.

    Parâmetros
    ----------
    index: bool (default=False)
        Se True, define a coluna &#39;pesquisa_id&#39; como index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Lista de pesquisas disponíveis no SIDRA.
    &#39;&#39;&#39;

    data = _api.get(&#39;&#39;)
    df = _normalize(
        data,
        &#39;agregados&#39;,
        [&#39;id&#39;, &#39;nome&#39;],
        record_prefix = &#39;tabela_&#39;,
        meta_prefix = &#39;pesquisa_&#39;
    )
    df = df[[&#39;pesquisa_id&#39;, &#39;pesquisa_nome&#39;]] \
        .drop_duplicates().reset_index(drop=True)

    if index:
        df.set_index(&#39;pesquisa_id&#39;, inplace=True)

    return df



class Metadados:
    &#39;&#39;&#39;
    Metadados da tabela desejada.

    Parâmetros
    ----------
    tabela: int
        Código numérico da tabela desejada.
        Utilize a função `ibge.lista_tabelas` para encontrar o código.

    Atributos
    ---------
    dados: dict
        Lista completa de metadados da tabela.
    cod: int
        Código numérico da tabela.
    nome: str
        Nome da tabela.
    assunto: str
        Assunto da tabela.
    periodos: dict
        Dicionário contendo a frequência, início e fim da tabela.
    localidades: dict
        Dicionário contendo os níveis territoriais da tabela.
    variaveis: list of dict
        Lista de variáveis disponíveis para a tabela.
    classificacoes: list of dict
        Lista de classificações e categorias disponíveis para a tabela.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    def __init__(self, tabela: int):
        data = _api.get(f&#39;/{tabela}/metadados&#39;)
        self.dados = data
        self.cod = tabela
        self.nome = data[&#39;nome&#39;]
        self.assunto = data[&#39;assunto&#39;]
        self.periodos = data[&#39;periodicidade&#39;]
        self.localidades = data[&#39;nivelTerritorial&#39;]
        self.variaveis = data[&#39;variaveis&#39;]
        self.classificacoes = data[&#39;classificacoes&#39;]



def sidra(
        tabela: int,
        periodos: Union[list, int, str] = &#39;last&#39;,
        variaveis: Union[list, int, str] = &#39;allxp&#39;,
        localidades: dict = {1: &#39;all&#39;},
        classificacoes: dict = None,
        ufs_extintas: bool = False,
        decimais: int = None,
        retorna: str = &#39;dataframe&#39;
    ) -&gt; Union[_pd.DataFrame, dict, str]:
    &#39;&#39;&#39;
    Função para captura de dados do SIDRA - Sistema IBGE de Recuperação
    Automática.

    Parâmetros
    ----------
    tabela: int
        Código numérico identificador da tabela.
    periodos: list, int ou str (default=&#39;last&#39;)
        Períodos de consulta desejados:
            - &#39;last&#39;: Último período;
            - &#39;last n&#39;: Últimos n períodos;
            - &#39;first&#39;: Primeiro período;
            - &#39;first n&#39;: Primeiros n períodos;
            - &#39;all&#39;: Todos os períodos disponíveis;
            - list: Lista de períodos desejados;
            - int: Um período específico;
            - Range de períodos separados por hífen.
    variaveis: list, int ou str (default=&#39;allxp&#39;)
        Variáveis de consulta desejadas:
            - &#39;all&#39;: Todas as variáveis disponíveis;
            - &#39;allxp&#39;: Todas as variáveis, exceto as percentuais;
            - list: Lista de variáveis;
            - int: Uma variáveis específica.
    localidades: dict (default={1:&#39;all&#39;})
        Localidades por nível territorial.
        As chaves dos dicionários devem ser o código de nível territorial:
            - 1: Brasil;
            - 2: Grande Região;
            - 3: Unidade da Federação;
            - 6: Município.
            - etc...
        Os valores do dicionário devem ser:
            - &#39;all&#39;: Todas as localidades do nível territorial.
            - list: Códigos dos territórios desejados.
            - int: Um território específico.
    classificacoes: dict (default=None)
        Dicionário de classificações e categorias.
        As chaves do dicionário devem ser o código da classificação.
        Os valores do dicionário devem ser:
            - &#39;all&#39;: Todas as categorias desta classificação;
            - &#39;allxt&#39;: Todas as categorias, exceto as totais;
            - list: Lista de categorias desejadas;
            - int: Uma categoria específica.
    ufs_extintas: bool (default=False)
        Se True, adiciona as UFs extintas (se disponível na tabela).
            - 20: Fernando de Noronha
            - 34: Guanabara
    decimais: int (default=None)
        Número de fixo de casas decimais do resultado, entre 0 e 9.
        Se None, utiliza o padrão de cada variável. 
    retorna: str (default=&#39;dataframe&#39;)
        Formato do dado retornado:
            - &#39;dataframe&#39;: Retorna um DataFrame Pandas;
            - &#39;json&#39;: Retorna um dicionário no formato json original;
            - &#39;url&#39;: Retorna a URL para consulta.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Se retorna=&#39;dataframe&#39;, retorna um DataFrame com os resultados.
    dict
        Se retorna=&#39;json&#39;, retorna um dicionário no formato json original.
    str
        Se retorna=&#39;url&#39;, retorna a URL para consulta.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    path = f&#39;http://api.sidra.ibge.gov.br/values/t/{tabela}&#39;

    if periodos is not None:
        if isinstance(periodos, list):
            periodos = &#39;,&#39;.join([str(i) for i in periodos])
        path += f&#39;/p/{periodos}&#39;

    if variaveis is not None:
        if isinstance(variaveis, list):
            variaveis = &#39;,&#39;.join([str(i) for i in variaveis])
        path += f&#39;/v/{variaveis}&#39;

    for n in localidades:
        if isinstance(localidades[n], list):
            valor = &#39;,&#39;.join([str(i) for i in localidades[n]])
        else:
            valor = localidades[n]
        path += f&#39;/n{n}/{valor}&#39;

    for c in classificacoes:
        if isinstance(classificacoes[c], list):
            valor = &#39;,&#39;.join([str(i) for i in classificacoes[c]])
        else:
            valor = classificacoes[c]
        path += f&#39;/c{c}/{valor}&#39;

    u = &#39;y&#39; if ufs_extintas else &#39;n&#39;
    d = &#39;s&#39; if decimais is None else decimais
    path += f&#39;/u/{u}/d/{d}&#39;

    if retorna == &#39;url&#39;:
        return path

    data = requests.get(path).json()
    if retorna == &#39;json&#39;:
        return data

    df = _pd.DataFrame(data[1:])
    df.columns = data[0].values()
    return df



def referencias(
        cod: str,
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém uma base de códigos para utilizar como argumento na busca do SIDRA.

    Parâmetros
    ----------
    cod: str
        - &#39;A&#39;: Assuntos;
        - &#39;C&#39;: Classificações;
        - &#39;N&#39;: Níveis geográficos;
        - &#39;P&#39;: Períodos;
        - &#39;E&#39;: Periodicidades;
        - &#39;V&#39;: Variáveis.
    index: bool (default=False)
        Defina True caso o campo &#39;id&#39; deva ser o index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo todas as referências do código pesquisado.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    if cod in [&#39;A&#39;, &#39;a&#39;, &#39;assuntos&#39;]:
        s = &#39;A&#39;
    elif cod in [&#39;C&#39;, &#39;c&#39;, &#39;classificacoes&#39;]:
        s = &#39;C&#39;
    elif cod in [&#39;N&#39;, &#39;n&#39;, &#39;niveis_geograficos&#39;, &#39;T&#39;, &#39;t&#39;, &#39;territorios&#39;]:
        s = &#39;N&#39;
    elif cod in [&#39;P&#39;, &#39;p&#39;, &#39;periodos&#39;]:
        s = &#39;P&#39;
    elif cod in [&#39;E&#39;, &#39;e&#39;, &#39;periodicidades&#39;]:
        s = &#39;E&#39;
    elif cod in [&#39;V&#39;, &#39;v&#39;, &#39;variaveis&#39;]:
        s = &#39;V&#39;
    else:
        raise ValueError(&#34;O campo &#39;cod&#39; deve ser do tipo string.&#34;)
        
    data = requests.get(f&#39;https://servicodados.ibge.gov.br/api/v3/agregados?acervo={s}&#39;).json()
    df = _pd.DataFrame(data)

    if index:
        df.set_index(&#39;id&#39;, inplace=True)
    
    return df


   
def populacao(
        projecao: str = None,
        localidade: int = None
    ) -&gt; Union[dict, int]:
    &#39;&#39;&#39;
    Obtém a projecao da população referente ao Brasil.

    Parâmetros
    ----------
    projecao: str (default=None)
        - &#39;populacao&#39; obtém o valor projetado da população total da localidade;
        - &#39;nascimento&#39; obtém o valor projetado de nascimentos da localidade
        - &#39;obito&#39; obtém o valor projetado de óbitos da localidade;
        - None obtém um dicionário com todos os valores anteriores.
    localidade: int (default=None)
        Código da localidade desejada.
        Por padrão, obtém os valores do Brasil.
        Utilize a função `ibge.localidades` para identificar
        a localidade desejada.

    Retorna
    -------
    dict ou int:
        Valor(es) projetado(s) para o indicador escolhido.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    localidade = _utils.parse_localidade(localidade, &#39;&#39;)
    query = f&#39;https://servicodados.ibge.gov.br/api/v1/projecoes/populacao/{localidade}&#39;
            
    r = requests.get(query).json()
    
    if projecao == None:
        return r
    elif projecao == &#39;populacao&#39;:
        return r[&#39;projecao&#39;][&#39;populacao&#39;]
    elif projecao == &#39;nascimento&#39;:
        return r[&#39;projecao&#39;][&#39;periodoMedio&#39;][&#39;nascimento&#39;]
    elif projecao == &#39;obito&#39;:
        return r[&#39;projecao&#39;][&#39;periodoMedio&#39;][&#39;obito&#39;]
    else:
        raise TypeError(&#34;O argumento &#39;projecao&#39; deve ser um dos seguintes valores tipo string: &#39;populacao&#39;, &#39;nascimento&#39; ou &#39;obito&#39;.&#34;)



def _loc_columns(x: str) -&gt; str:
    &#39;&#39;&#39;
    Função de suporte à função `ibge.localidades`.
    Usada para renomear as colunas do DataFrame de distritos.
    &#39;&#39;&#39;

    y = x.replace(&#39;-&#39;, &#39;_&#39;).split(&#39;.&#39;)
    return f&#39;{y[-2]}_{y[-1]}&#39; if len(y)&gt;1 else y[0]



def localidades() -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém o conjunto de distritos do Brasil.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo todas as divisões de distritos do Brasil.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    df = _normalize(
        requests.get(
            r&#39;https://servicodados.ibge.gov.br/api/v1/localidades/distritos&#39;
        ).json()
    )

    df.columns = df.columns.map(_loc_columns)
    return df.loc[:,~df.columns.duplicated()]



def malha(localidade:int=None) -&gt; str:
    &#39;&#39;&#39;
    Obtém a URL para a malha referente ao identificador da localidade.

    Parâmetros
    ----------
    localidade: int (default=None)
        Código da localidade desejada.
        Por padrão, obtém a malha do Brasil.
        Utilize a função `ibge.localidades` para identificar
        a localidade desejada.

    Retorna
    -------
    str
        URL da malha da localidade desejada.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    localidade = _utils.parse_localidade(localidade, &#39;&#39;)
    return f&#39;https://servicodados.ibge.gov.br/api/v2/malhas/{localidade}&#39;



def coordenadas() -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém as coordenadas de todas as localidades brasileiras, incluindo
    latitude, longitude e altitude.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame das coordenadas de todas as localidade brasileiras.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    return _pd.read_excel(
        r&#39;https://raw.githubusercontent.com/GusFurtado/DadosAbertosBrasil/master/data/Coordenadas.xlsx&#39;
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Funções</h2>
<dl>
<dt id="DadosAbertosBrasil.ibge.coordenadas"><code class="name flex">
<span>def <span class="ident">coordenadas</span></span>(<span>) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém as coordenadas de todas as localidades brasileiras, incluindo
latitude, longitude e altitude.</p>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame das coordenadas de todas as localidade brasileiras.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def coordenadas() -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém as coordenadas de todas as localidades brasileiras, incluindo
    latitude, longitude e altitude.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame das coordenadas de todas as localidade brasileiras.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    return _pd.read_excel(
        r&#39;https://raw.githubusercontent.com/GusFurtado/DadosAbertosBrasil/master/data/Coordenadas.xlsx&#39;
    )</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.lista_pesquisas"><code class="name flex">
<span>def <span class="ident">lista_pesquisas</span></span>(<span>index: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Lista de pesquisas disponíveis no SIDRA.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>index: bool (default=False)
    Se True, define a coluna 'pesquisa_id' como index do DataFrame.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    Lista de pesquisas disponíveis no SIDRA.</pre></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def lista_pesquisas(
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Lista de pesquisas disponíveis no SIDRA.

    Parâmetros
    ----------
    index: bool (default=False)
        Se True, define a coluna &#39;pesquisa_id&#39; como index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Lista de pesquisas disponíveis no SIDRA.
    &#39;&#39;&#39;

    data = _api.get(&#39;&#39;)
    df = _normalize(
        data,
        &#39;agregados&#39;,
        [&#39;id&#39;, &#39;nome&#39;],
        record_prefix = &#39;tabela_&#39;,
        meta_prefix = &#39;pesquisa_&#39;
    )
    df = df[[&#39;pesquisa_id&#39;, &#39;pesquisa_nome&#39;]] \
        .drop_duplicates().reset_index(drop=True)

    if index:
        df.set_index(&#39;pesquisa_id&#39;, inplace=True)

    return df</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.lista_tabelas"><code class="name flex">
<span>def <span class="ident">lista_tabelas</span></span>(<span>pesquisa: str = None, contendo: str = None, excluindo: str = None, index: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Lista de tabelas disponíveis no SIDRA.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>pesquisa: str (default=None)
    Código de duas letras da pesquisa que será buscada.
    Utilize a função `ibge_lista_pesquisas` para encontrar o código.
contendo: str (default=None)
    Buscar apenas tabelas que contenham essa sequência de caracteres.
excluindo: str (default=None)
    Buscar tabelas que não contenham essa sequência de caracteres.
index: bool (default=False)
    Se True, define a coluna 'tabela_id' como index do DataFrame.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    Lista de tabelas disponíveis no SIDRA.</pre></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def lista_tabelas(
        pesquisa: str = None,
        contendo: str = None,
        excluindo: str = None,
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Lista de tabelas disponíveis no SIDRA.

    Parâmetros
    ----------
    pesquisa: str (default=None)
        Código de duas letras da pesquisa que será buscada.
        Utilize a função `ibge_lista_pesquisas` para encontrar o código.
    contendo: str (default=None)
        Buscar apenas tabelas que contenham essa sequência de caracteres.
    excluindo: str (default=None)
        Buscar tabelas que não contenham essa sequência de caracteres.
    index: bool (default=False)
        Se True, define a coluna &#39;tabela_id&#39; como index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Lista de tabelas disponíveis no SIDRA.
    &#39;&#39;&#39;

    data = _api.get(&#39;&#39;)
    df = _normalize(
        data,
        &#39;agregados&#39;,
        [&#39;id&#39;, &#39;nome&#39;],
        record_prefix = &#39;tabela_&#39;,
        meta_prefix = &#39;pesquisa_&#39;
    )
    df.tabela_id = _pd.to_numeric(df.tabela_id)

    if isinstance(pesquisa, str):
        df = df[df.pesquisa_id == pesquisa.upper()]
    elif pesquisa == None:
        pass
    else:
        raise TypeError(&#34;O argumento &#39;pesquisa&#39; deve ser tipo string com duas letras.&#34;)
        
    if isinstance(contendo, str):
        df = df[df.tabela_nome.str.contains(contendo)]
    elif contendo == None:
        pass
    else:
        raise TypeError(&#39;O texto procurado deve ser tipo string.&#39;)
        
    if isinstance(excluindo, str):
        df = df[~df.tabela_nome.str.contains(excluindo)]
    elif excluindo == None:
        pass
    else:
        raise TypeError(&#39;O texto procurado deve ser tipo string.&#39;)

    if index:
        df.set_index(&#39;tabela_id&#39;, inplace=True)

    return df</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.localidades"><code class="name flex">
<span>def <span class="ident">localidades</span></span>(<span>) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o conjunto de distritos do Brasil.</p>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame contendo todas as divisões de distritos do Brasil.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def localidades() -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém o conjunto de distritos do Brasil.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo todas as divisões de distritos do Brasil.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    df = _normalize(
        requests.get(
            r&#39;https://servicodados.ibge.gov.br/api/v1/localidades/distritos&#39;
        ).json()
    )

    df.columns = df.columns.map(_loc_columns)
    return df.loc[:,~df.columns.duplicated()]</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.malha"><code class="name flex">
<span>def <span class="ident">malha</span></span>(<span>localidade: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém a URL para a malha referente ao identificador da localidade.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>localidade: int (default=None)
    Código da localidade desejada.
    Por padrão, obtém a malha do Brasil.
    Utilize a função `ibge.localidades` para identificar a localidade
    desejada.</pre>
<h2 id="retorna">Retorna</h2>
<pre>str
    URL da malha da localidade desejada.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def malha(localidade:int=None) -&gt; str:
    &#39;&#39;&#39;
    Obtém a URL para a malha referente ao identificador da localidade.

    Parâmetros
    ----------
    localidade: int (default=None)
        Código da localidade desejada.
        Por padrão, obtém a malha do Brasil.
        Utilize a função `ibge.localidades` para identificar
        a localidade desejada.

    Retorna
    -------
    str
        URL da malha da localidade desejada.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    localidade = _utils.parse_localidade(localidade, &#39;&#39;)
    return f&#39;https://servicodados.ibge.gov.br/api/v2/malhas/{localidade}&#39;</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.nomes"><code class="name flex">
<span>def <span class="ident">nomes</span></span>(<span>nomes: Union[list, str], sexo: str = None, localidade: int = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém a frequência de nascimentos por década dos nomes consultados.
Defina o campo 'nomes' com um string ou uma lista de string.
Use os argumentos opcionais para definir sexo e localidade dos nomes.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>nomes: list ou str
    Nome ou lista de nomes a ser consultado.
sexo: str (default=None)
    - 'M' para consultar apenas o nome de pessoas do sexo masculino;
    - 'F' para consultar apenas o nome de pessoas do sexo feminino;
    - None para consultar ambos.
localidade: int (default=None)
    Caso deseje obter a frequência referente a uma dada localidade,
    informe o parâmetro localidade. Por padrão, assume o valor BR,
    mas pode ser o identificador de um município ou de uma UF.
    Utilize a função `ibge.localidade` para encontrar a localidade
    desejada.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame contendo a frequência de nascimentos por década para
    o(s) nome(s) consultado(s).</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def nomes(
        nomes: Union[list, str],
        sexo: str = None,
        localidade: int = None
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém a frequência de nascimentos por década dos nomes consultados.
    Defina o campo &#39;nomes&#39; com um string ou uma lista de string.
    Use os argumentos opcionais para definir sexo e localidade dos nomes.

    Parâmetros
    ----------
    nomes: list ou str
        Nome ou lista de nomes a ser consultado.
    sexo: str (default=None)
        - &#39;M&#39; para consultar apenas o nome de pessoas do sexo masculino;
        - &#39;F&#39; para consultar apenas o nome de pessoas do sexo feminino;
        - None para consultar ambos.
    localidade: int (default=None)
        Caso deseje obter a frequência referente a uma dada localidade,
        informe o parâmetro localidade. Por padrão, assume o valor BR,
        mas pode ser o identificador de um município ou de uma UF.
        Utilize a função `ibge.localidade` para encontrar a localidade
        desejada.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo a frequência de nascimentos por década para
        o(s) nome(s) consultado(s).

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    if isinstance(nomes, list):
        nomes = &#39;|&#39;.join(nomes)

    params = {}
    if sexo is not None:
        params[&#39;sexo&#39;] = sexo
    if localidade is not None:
        params[&#39;localidade&#39;] = _utils.parse_localidade(localidade)

    url = f&#34;https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nomes}&#34;
    data = requests.get(url, params=params).json()
    json = _pd.DataFrame(data)

    dfs = [_pd.DataFrame(json.res[i]).set_index(&#39;periodo&#39;) for i in json.index]
    df = _pd.concat(dfs, axis=1)
    df.columns = json.nome

    return df</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.nomes_ranking"><code class="name flex">
<span>def <span class="ident">nomes_ranking</span></span>(<span>decada: int = None, sexo: str = None, localidade: int = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o ranking dos nomes segundo a frequência de nascimentos por década.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>decada: int (default=None)
    Deve ser um número múltiplo de 10 no formato AAAA.
sexo: str (default=None)
    - 'M' para consultar apenas o nome de pessoas do sexo masculino;
    - 'F' para consultar apenas o nome de pessoas do sexo feminino;
    - None para consultar ambos.
localidade: int (default=None)
    Caso deseje obter o ranking de nomes referente a uma dada localidade,
    informe o parâmetro localidade. Por padrão, assume o valor BR,
    mas pode ser o identificador de um município ou de uma UF.
    Utilize a função `ibge.localidade` para encontrar a localidade
    desejada.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame contendo os nomes mais populadores dentro do universo de
    parâmetros pesquisados.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def nomes_ranking(
        decada: int = None,
        sexo: str = None,
        localidade: int = None
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém o ranking dos nomes segundo a frequência de nascimentos por década.

    Parâmetros
    ----------
    decada: int (default=None)
        Deve ser um número múltiplo de 10 no formato AAAA.
    sexo: str (default=None)
        - &#39;M&#39; para consultar apenas o nome de pessoas do sexo masculino;
        - &#39;F&#39; para consultar apenas o nome de pessoas do sexo feminino;
        - None para consultar ambos.
    localidade: int (default=None)
        Caso deseje obter o ranking de nomes referente a uma dada localidade,
        informe o parâmetro localidade. Por padrão, assume o valor BR,
        mas pode ser o identificador de um município ou de uma UF.
        Utilize a função `ibge.localidade` para encontrar a localidade
        desejada.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo os nomes mais populadores dentro do universo de
        parâmetros pesquisados.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    query = &#39;https://servicodados.ibge.gov.br/api/v2/censos/nomes/ranking&#39;
    params = []
    
    if decada is not None:
        decada_error = &#34;O argumento &#39;decada&#39; deve ser um número inteiro multiplo de 10.&#34;
        if isinstance(decada, int):
            if decada%10 == 0:
                params.append(f&#39;decada={decada}&#39;)
            else:
                raise ValueError(decada_error)
        else:
            raise TypeError(decada_error)
    
    if localidade is not None:
        params.append(f&#39;localidade={_utils.parse_localidade(localidade)}&#39;)
            
    if sexo is not None:
        if sexo in [&#39;M&#39;, &#39;m&#39;, &#39;F&#39;, &#39;f&#39;]:
            params.append(f&#39;sexo={sexo.upper()}&#39;)
        else:
            raise ValueError(&#34;O argumento &#39;sexo&#39; deve ser um tipo &#39;string&#39; igual a &#39;M&#39; para masculino ou &#39;F&#39; para feminino.&#34;)
    
    params = &#39;&amp;&#39;.join(params)
    if params != &#39;&#39;:
        query += f&#39;?{params}&#39;
    
    return _pd.DataFrame(
        _pd.read_json(query).res[0]
    ).set_index(&#39;ranking&#39;)</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.nomes_uf"><code class="name flex">
<span>def <span class="ident">nomes_uf</span></span>(<span>nome: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém a frequência de nascimentos por UF para o nome consultado.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>nome: str
    Nome que se deseja pesquisar.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame contendo a frequência de nascimentos do nome pesquisado,
    agrupado por Unidade da Federação.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def nomes_uf(nome: str) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém a frequência de nascimentos por UF para o nome consultado.

    Parâmetros
    ----------
    nome: str
        Nome que se deseja pesquisar.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo a frequência de nascimentos do nome pesquisado,
        agrupado por Unidade da Federação.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;
    
    if isinstance(nome, str):

        json = _pd.read_json(
            f&#34;https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nome}?groupBy=UF&#34;
        )

        df = _pd.DataFrame(
            [json[json.localidade == i].res.values[0][0] for i in json.localidade]
        )

        df.index = json.localidade
        df.sort_index(inplace=True)
        
    else:
        raise TypeError(&#34;O argumento &#39;nome&#39; deve ser do tipo string.&#34;)
    
    return df</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.populacao"><code class="name flex">
<span>def <span class="ident">populacao</span></span>(<span>projecao: str = None, localidade: int = None) ‑> Union[dict, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém a projecao da população referente ao Brasil.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>projecao: str (default=None)
    - 'populacao' obtém o valor projetado da população total da localidade;
    - 'nascimento' obtém o valor projetado de nascimentos da localidade
    - 'obito' obtém o valor projetado de óbitos da localidade;
    - None obtém um dicionário com todos os valores anteriores.
localidade: int (default=None)
    Código da localidade desejada.
    Por padrão, obtém os valores do Brasil.
    Utilize a função `ibge.localidades` para identificar
    a localidade desejada.</pre>
<h2 id="retorna">Retorna</h2>
<pre>dict ou int:
    Valor(es) projetado(s) para o indicador escolhido.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def populacao(
        projecao: str = None,
        localidade: int = None
    ) -&gt; Union[dict, int]:
    &#39;&#39;&#39;
    Obtém a projecao da população referente ao Brasil.

    Parâmetros
    ----------
    projecao: str (default=None)
        - &#39;populacao&#39; obtém o valor projetado da população total da localidade;
        - &#39;nascimento&#39; obtém o valor projetado de nascimentos da localidade
        - &#39;obito&#39; obtém o valor projetado de óbitos da localidade;
        - None obtém um dicionário com todos os valores anteriores.
    localidade: int (default=None)
        Código da localidade desejada.
        Por padrão, obtém os valores do Brasil.
        Utilize a função `ibge.localidades` para identificar
        a localidade desejada.

    Retorna
    -------
    dict ou int:
        Valor(es) projetado(s) para o indicador escolhido.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    localidade = _utils.parse_localidade(localidade, &#39;&#39;)
    query = f&#39;https://servicodados.ibge.gov.br/api/v1/projecoes/populacao/{localidade}&#39;
            
    r = requests.get(query).json()
    
    if projecao == None:
        return r
    elif projecao == &#39;populacao&#39;:
        return r[&#39;projecao&#39;][&#39;populacao&#39;]
    elif projecao == &#39;nascimento&#39;:
        return r[&#39;projecao&#39;][&#39;periodoMedio&#39;][&#39;nascimento&#39;]
    elif projecao == &#39;obito&#39;:
        return r[&#39;projecao&#39;][&#39;periodoMedio&#39;][&#39;obito&#39;]
    else:
        raise TypeError(&#34;O argumento &#39;projecao&#39; deve ser um dos seguintes valores tipo string: &#39;populacao&#39;, &#39;nascimento&#39; ou &#39;obito&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.referencias"><code class="name flex">
<span>def <span class="ident">referencias</span></span>(<span>cod: str, index: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém uma base de códigos para utilizar como argumento na busca do SIDRA.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>cod: str
    - 'A': Assuntos;
    - 'C': Classificações;
    - 'N': Níveis geográficos;
    - 'P': Períodos;
    - 'E': Periodicidades;
    - 'V': Variáveis.
index: bool (default=False)
    Defina True caso o campo 'id' deva ser o index do DataFrame.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    DataFrame contendo todas as referências do código pesquisado.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def referencias(
        cod: str,
        index: bool = False
    ) -&gt; _pd.DataFrame:
    &#39;&#39;&#39;
    Obtém uma base de códigos para utilizar como argumento na busca do SIDRA.

    Parâmetros
    ----------
    cod: str
        - &#39;A&#39;: Assuntos;
        - &#39;C&#39;: Classificações;
        - &#39;N&#39;: Níveis geográficos;
        - &#39;P&#39;: Períodos;
        - &#39;E&#39;: Periodicidades;
        - &#39;V&#39;: Variáveis.
    index: bool (default=False)
        Defina True caso o campo &#39;id&#39; deva ser o index do DataFrame.

    Retorna
    -------
    pandas.core.frame.DataFrame
        DataFrame contendo todas as referências do código pesquisado.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    if cod in [&#39;A&#39;, &#39;a&#39;, &#39;assuntos&#39;]:
        s = &#39;A&#39;
    elif cod in [&#39;C&#39;, &#39;c&#39;, &#39;classificacoes&#39;]:
        s = &#39;C&#39;
    elif cod in [&#39;N&#39;, &#39;n&#39;, &#39;niveis_geograficos&#39;, &#39;T&#39;, &#39;t&#39;, &#39;territorios&#39;]:
        s = &#39;N&#39;
    elif cod in [&#39;P&#39;, &#39;p&#39;, &#39;periodos&#39;]:
        s = &#39;P&#39;
    elif cod in [&#39;E&#39;, &#39;e&#39;, &#39;periodicidades&#39;]:
        s = &#39;E&#39;
    elif cod in [&#39;V&#39;, &#39;v&#39;, &#39;variaveis&#39;]:
        s = &#39;V&#39;
    else:
        raise ValueError(&#34;O campo &#39;cod&#39; deve ser do tipo string.&#34;)
        
    data = requests.get(f&#39;https://servicodados.ibge.gov.br/api/v3/agregados?acervo={s}&#39;).json()
    df = _pd.DataFrame(data)

    if index:
        df.set_index(&#39;id&#39;, inplace=True)
    
    return df</code></pre>
</details>
</dd>
<dt id="DadosAbertosBrasil.ibge.sidra"><code class="name flex">
<span>def <span class="ident">sidra</span></span>(<span>tabela: int, periodos: Union[list, int, str] = 'last', variaveis: Union[list, int, str] = 'allxp', localidades: dict = {1: 'all'}, classificacoes: dict = None, ufs_extintas: bool = False, decimais: int = None, retorna: str = 'dataframe') ‑> Union[pandas.core.frame.DataFrame, dict, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Função para captura de dados do SIDRA - Sistema IBGE de Recuperação
Automática.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>tabela: int
    Código numérico identificador da tabela.
periodos: list, int ou str (default='last')
    Períodos de consulta desejados:
        - 'last': Último período;
        - 'last n': Últimos n períodos;
        - 'first': Primeiro período;
        - 'first n': Primeiros n períodos;
        - 'all': Todos os períodos disponíveis;
        - list: Lista de períodos desejados;
        - int: Um período específico;
        - Range de períodos separados por hífen.
variaveis: list, int ou str (default='allxp')
    Variáveis de consulta desejadas:
        - 'all': Todas as variáveis disponíveis;
        - 'allxp': Todas as variáveis, exceto as percentuais;
        - list: Lista de variáveis;
        - int: Uma variáveis específica.
localidades: dict (default={1:'all'})
    Localidades por nível territorial.
    As chaves dos dicionários devem ser o código de nível territorial:
        - 1: Brasil;
        - 2: Grande Região;
        - 3: Unidade da Federação;
        - 6: Município.
        - etc&hellip;
    Os valores do dicionário devem ser:
        - 'all': Todas as localidades do nível territorial.
        - list: Códigos dos territórios desejados.
        - int: Um território específico.
classificacoes: dict (default=None)
    Dicionário de classificações e categorias.
    As chaves do dicionário devem ser o código da classificação.
    Os valores do dicionário devem ser:
        - 'all': Todas as categorias desta classificação;
        - 'allxt': Todas as categorias, exceto as totais;
        - list: Lista de categorias desejadas;
        - int: Uma categoria específica.
ufs_extintas: bool (default=False)
    Se True, adiciona as UFs extintas (se disponível na tabela).
        - 20: Fernando de Noronha
        - 34: Guanabara
decimais: int (default=None)
    Número de fixo de casas decimais do resultado, entre 0 e 9.
    Se None, utiliza o padrão de cada variável.
retorna: str (default='dataframe')
    Formato do dado retornado:
        - 'dataframe': Retorna um DataFrame Pandas;
        - 'json': Retorna um dicionário no formato json original;
        - 'url': Retorna a URL para consulta.</pre>
<h2 id="retorna">Retorna</h2>
<pre>pandas.core.frame.DataFrame
    Se retorna='dataframe', retorna um DataFrame com os resultados.
dict
    Se retorna='json', retorna um dicionário no formato json original.
str
    Se retorna='url', retorna a URL para consulta.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">def sidra(
        tabela: int,
        periodos: Union[list, int, str] = &#39;last&#39;,
        variaveis: Union[list, int, str] = &#39;allxp&#39;,
        localidades: dict = {1: &#39;all&#39;},
        classificacoes: dict = None,
        ufs_extintas: bool = False,
        decimais: int = None,
        retorna: str = &#39;dataframe&#39;
    ) -&gt; Union[_pd.DataFrame, dict, str]:
    &#39;&#39;&#39;
    Função para captura de dados do SIDRA - Sistema IBGE de Recuperação
    Automática.

    Parâmetros
    ----------
    tabela: int
        Código numérico identificador da tabela.
    periodos: list, int ou str (default=&#39;last&#39;)
        Períodos de consulta desejados:
            - &#39;last&#39;: Último período;
            - &#39;last n&#39;: Últimos n períodos;
            - &#39;first&#39;: Primeiro período;
            - &#39;first n&#39;: Primeiros n períodos;
            - &#39;all&#39;: Todos os períodos disponíveis;
            - list: Lista de períodos desejados;
            - int: Um período específico;
            - Range de períodos separados por hífen.
    variaveis: list, int ou str (default=&#39;allxp&#39;)
        Variáveis de consulta desejadas:
            - &#39;all&#39;: Todas as variáveis disponíveis;
            - &#39;allxp&#39;: Todas as variáveis, exceto as percentuais;
            - list: Lista de variáveis;
            - int: Uma variáveis específica.
    localidades: dict (default={1:&#39;all&#39;})
        Localidades por nível territorial.
        As chaves dos dicionários devem ser o código de nível territorial:
            - 1: Brasil;
            - 2: Grande Região;
            - 3: Unidade da Federação;
            - 6: Município.
            - etc...
        Os valores do dicionário devem ser:
            - &#39;all&#39;: Todas as localidades do nível territorial.
            - list: Códigos dos territórios desejados.
            - int: Um território específico.
    classificacoes: dict (default=None)
        Dicionário de classificações e categorias.
        As chaves do dicionário devem ser o código da classificação.
        Os valores do dicionário devem ser:
            - &#39;all&#39;: Todas as categorias desta classificação;
            - &#39;allxt&#39;: Todas as categorias, exceto as totais;
            - list: Lista de categorias desejadas;
            - int: Uma categoria específica.
    ufs_extintas: bool (default=False)
        Se True, adiciona as UFs extintas (se disponível na tabela).
            - 20: Fernando de Noronha
            - 34: Guanabara
    decimais: int (default=None)
        Número de fixo de casas decimais do resultado, entre 0 e 9.
        Se None, utiliza o padrão de cada variável. 
    retorna: str (default=&#39;dataframe&#39;)
        Formato do dado retornado:
            - &#39;dataframe&#39;: Retorna um DataFrame Pandas;
            - &#39;json&#39;: Retorna um dicionário no formato json original;
            - &#39;url&#39;: Retorna a URL para consulta.

    Retorna
    -------
    pandas.core.frame.DataFrame
        Se retorna=&#39;dataframe&#39;, retorna um DataFrame com os resultados.
    dict
        Se retorna=&#39;json&#39;, retorna um dicionário no formato json original.
    str
        Se retorna=&#39;url&#39;, retorna a URL para consulta.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    path = f&#39;http://api.sidra.ibge.gov.br/values/t/{tabela}&#39;

    if periodos is not None:
        if isinstance(periodos, list):
            periodos = &#39;,&#39;.join([str(i) for i in periodos])
        path += f&#39;/p/{periodos}&#39;

    if variaveis is not None:
        if isinstance(variaveis, list):
            variaveis = &#39;,&#39;.join([str(i) for i in variaveis])
        path += f&#39;/v/{variaveis}&#39;

    for n in localidades:
        if isinstance(localidades[n], list):
            valor = &#39;,&#39;.join([str(i) for i in localidades[n]])
        else:
            valor = localidades[n]
        path += f&#39;/n{n}/{valor}&#39;

    for c in classificacoes:
        if isinstance(classificacoes[c], list):
            valor = &#39;,&#39;.join([str(i) for i in classificacoes[c]])
        else:
            valor = classificacoes[c]
        path += f&#39;/c{c}/{valor}&#39;

    u = &#39;y&#39; if ufs_extintas else &#39;n&#39;
    d = &#39;s&#39; if decimais is None else decimais
    path += f&#39;/u/{u}/d/{d}&#39;

    if retorna == &#39;url&#39;:
        return path

    data = requests.get(path).json()
    if retorna == &#39;json&#39;:
        return data

    df = _pd.DataFrame(data[1:])
    df.columns = data[0].values()
    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="DadosAbertosBrasil.ibge.Metadados"><code class="flex name class">
<span>class <span class="ident">Metadados</span></span>
<span>(</span><span>tabela: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Metadados da tabela desejada.</p>
<h2 id="parametros">Parâmetros</h2>
<pre>tabela: int
    Código numérico da tabela desejada.
    Utilize a função `ibge.lista_tabelas` para encontrar o código.</pre>
<h2 id="atributos">Atributos</h2>
<pre>dados: dict
    Lista completa de metadados da tabela.
cod: int
    Código numérico da tabela.
nome: str
    Nome da tabela.
assunto: str
    Assunto da tabela.
periodos: dict
    Dicionário contendo a frequência, início e fim da tabela.
localidades: dict
    Dicionário contendo os níveis territoriais da tabela.
variaveis: list of dict
    Lista de variáveis disponíveis para a tabela.
classificacoes: list of dict
    Lista de classificações e categorias disponíveis para a tabela.</pre>
<hr></div>
<details class="source">
<summary>
<span>Expandir código-fonte</span>
</summary>
<pre><code class="python">class Metadados:
    &#39;&#39;&#39;
    Metadados da tabela desejada.

    Parâmetros
    ----------
    tabela: int
        Código numérico da tabela desejada.
        Utilize a função `ibge.lista_tabelas` para encontrar o código.

    Atributos
    ---------
    dados: dict
        Lista completa de metadados da tabela.
    cod: int
        Código numérico da tabela.
    nome: str
        Nome da tabela.
    assunto: str
        Assunto da tabela.
    periodos: dict
        Dicionário contendo a frequência, início e fim da tabela.
    localidades: dict
        Dicionário contendo os níveis territoriais da tabela.
    variaveis: list of dict
        Lista de variáveis disponíveis para a tabela.
    classificacoes: list of dict
        Lista de classificações e categorias disponíveis para a tabela.

    --------------------------------------------------------------------------
    &#39;&#39;&#39;

    def __init__(self, tabela: int):
        data = _api.get(f&#39;/{tabela}/metadados&#39;)
        self.dados = data
        self.cod = tabela
        self.nome = data[&#39;nome&#39;]
        self.assunto = data[&#39;assunto&#39;]
        self.periodos = data[&#39;periodicidade&#39;]
        self.localidades = data[&#39;nivelTerritorial&#39;]
        self.variaveis = data[&#39;variaveis&#39;]
        self.classificacoes = data[&#39;classificacoes&#39;]</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DadosAbertosBrasil" href="https://gustavofurtado.com/dab/">
<img src="https://raw.githubusercontent.com/GusFurtado/DadosAbertosBrasil/master/assets/logo.png" alt="DadosAbertosBrasil">
</a>
</header>
<h1>Sumário</h1>
<div class="toc">
<ul>
<li><a href="#servicos-disponiveis">Serviços Disponíveis</a></li>
<li><a href="#mini-tutorial-de-sidra">Mini-Tutorial de SIDRA</a></li>
<li><a href="#documentacao-da-api-original">Documentação original</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-módulo</h3>
<ul>
<li><code><a title="DadosAbertosBrasil" href="index.html">DadosAbertosBrasil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Funções</a></h3>
<ul class="two-column">
<li><code><a title="DadosAbertosBrasil.ibge.coordenadas" href="#DadosAbertosBrasil.ibge.coordenadas">coordenadas</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.lista_pesquisas" href="#DadosAbertosBrasil.ibge.lista_pesquisas">lista_pesquisas</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.lista_tabelas" href="#DadosAbertosBrasil.ibge.lista_tabelas">lista_tabelas</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.localidades" href="#DadosAbertosBrasil.ibge.localidades">localidades</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.malha" href="#DadosAbertosBrasil.ibge.malha">malha</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.nomes" href="#DadosAbertosBrasil.ibge.nomes">nomes</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.nomes_ranking" href="#DadosAbertosBrasil.ibge.nomes_ranking">nomes_ranking</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.nomes_uf" href="#DadosAbertosBrasil.ibge.nomes_uf">nomes_uf</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.populacao" href="#DadosAbertosBrasil.ibge.populacao">populacao</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.referencias" href="#DadosAbertosBrasil.ibge.referencias">referencias</a></code></li>
<li><code><a title="DadosAbertosBrasil.ibge.sidra" href="#DadosAbertosBrasil.ibge.sidra">sidra</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="DadosAbertosBrasil.ibge.Metadados" href="#DadosAbertosBrasil.ibge.Metadados">Metadados</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>